这是一个生成的文件,不要直接编辑
========================================================
--------------------------------------------------------
1.2 showing where you are
$pwd
显示当前目录
$export PS1='[\u@\h \w]'
修改Prompt
$pwd -L
对于符号链接，显示逻辑位置（默认）
$pwd -P
显示物理位置
--------------------------------------------------------
1.3 找命令
$which ls
显示命令ls的路径
$type ls
显示命令ls的路径，包括alias
$type -a ls
显示PATH中所有的ls命令，包括alias
$apropos ls
根据字符串找命令（当你忘记命令名字时用，也可man -k ls）
$locate apropos
找名字中有apropos的文件
--------------------------------------------------------
1.4 获得文件的信息
$stat <filename>
查看文件i-node的详细信息

$file <filename>
查看文件类型(和文件的编码)
--------------------------------------------------------
1.6 双引号和单引号的使用
$echo “A coffee is $5?”
A coffee is ?
#因为$5被解析成变量
$echo "A coffee is $5?!"
报错，因为!不能用在双引号中，becaus ‘！’ is treated as a history substitution.
$echo 'A coffee is $5?!'
A coffee is $5?!
#单引号中不会进行shell解析
$echo "A coffee is \$5?\!"
#将$和!进行转义，一样能输出正确的结果
--------------------------------------------------------
1.8 查看当前运行的是否为可交互的Bash
文件：interative.sh
--------------------------------------------------------
========================================================
----------------------------------------------------------
2.1 输出到终端
$echo Please wait
Please wait
$echo this     was     very    widely   spaced
this was very widely spaced
$echo "this     was     very    widely   spaced"
this     was     very    widely   spaced
$echo -n somethings
somethings$
----------------------------------------------------------
2.3 格式化输出
$value=28
$printf "%s = %d\n" Lines $value
Lines = 28
$printf "%-10.10s=%4.2f\n" 'GigaHerz' 1.92735
GigaHerz  =1.93
#printf命令和C语言中的printf函数类似
----------------------------------------------------------
2.8 重定向到不同文件
$myprogram > msg_stdout.txt 2> meg_stderr.txt
----------------------------------------------------------
2.9 重定向到相同文件
$myprogram >& outfile.txt
或
$myprogram &> outfile.txt
或
$myprogram > outfile.txt 2>&1
----------------------------------------------------------
2.10 将重定向内容写到文件末端
ls >> /tmp/ls.out
----------------------------------------------------------
2.11 使用文件的开头或结尾
$head -n 5 <filename>
开头5行
$tail -n 5 <filename>
结尾5行
$tail -n +5 <filename>
从第五行（包括）到文件末尾
----------------------------------------------------------
2.13 丢弃输出
$find / -name myfile -print 2> /dev/null
将find命令的错误输出流重定向到/dev/null（即丢弃）
----------------------------------------------------------
2.14 重定向多个命令的输出
$(pwd;ls;cd ..;pwd;ls) > /tmp/tempFile.txt
----------------------------------------------------------
2.15 用管道链接两个命令的输入和输出
$cat note02.txt | sort
或者
$sort < note02.txt
----------------------------------------------------------
2.16 tee命令的使用
$cat my*| tr 'a-z' 'A-Z' | uniq | wc
当想看到上面的命令中uniq和wc之间被重定向的内容，用以下的命令
$cat my*| tr 'a-z' 'A-Z' | uniq | tee file1.txt |wc
----------------------------------------------------------
2.17 用一个程序的输出作为另一个程序的参数
$rm $(find . -name '*.class')
----------------------------------------------------------
*2.18 复合从定向的使用（不推荐使用）
$divert 3>three.txt 4> fout.txt 5> five.txt 
将文件描述符为3～5的文件重定向到不同的地方
----------------------------------------------------------
*2.20 交换STDERR和STDOUT
./myscript 3>&1 1>stdout.logfile 2>&3- | tee -a stderr.logfile
----------------------------------------------------------
2.21 防止既有的文件被重定向修改
$set -o noclobber
防止既有的文件被重定向修改
$set +o nuclobber
取消以上的设置
$echo something >| my.file
强制将输出重定向到文件my.file
(即使设置了以上内容且my.file已经存在，亦会覆盖my.file)
----------------------------------------------------------

========================================================
-------------------------------------------
3.1 从文件获得输入
$wc < my.file
-------------------------------------------
3.2 Here document:在Script文件中保存要输入的数据
here_document01.sh
-------------------------------------------
3.3 防止here document中的 “$1”解析成命令行参数
here_document02.sh
-------------------------------------------
3.4 在here document中,使用缩进
here_document03.sh
-------------------------------------------
3.5 获得用户的输入
$read
将读的值存到变量REPLY中
$read -p "answer me this:" ANSWER
提示“answer me this:”，并将输入的值存到变量ANSWER中
$read PRE MID POST
依次为PRE MID POST赋值
如果输入“a b c d”,则PRE=a MID=b POST=“c d”
如果输入“a b c”,则PRE=a MID=b POST=c
如果输入“a b”,则PRE=a MID=b POST为空
-------------------------------------------
3.6 获得是或者否
func_choose.sh		在参数中输入是或否时该执行的变量
func_choose.1.sh	要求输入是或否，将结果值存到 $CHOICE
func_choose.2.sh	确认用户的输入
func_choose.3.sh 	输入最喜欢的颜色，或则直接敲回车（结果为空）
-------------------------------------------
3.7 在多个选项中选择一项
select_dir.sh		select命令的使用
（修改PS3并select $value in $list;do <一些处理> done ）
-------------------------------------------
3.8 输入密码（虽可行，但不太安全的做法，密码记录到全局变量中）
read -s -p "Please input the password:" PASSWD
printf "%b" "\n" (负责换行，%b认为“\n”是换行符)
-------------------------------------------
========================================================
-------------------------------------------------
4.2 上一条命令是否成功执行（用变量$?）
$somecommand
$echo $?
如果执行成功，$?的值为0，否则$?的值为非零的值
-------------------------------------------------
4.4 用 & 在后台运行程序
$ gnome-open . &
将在shell的后台运行gnome-open命令，且在控制台输出进程id
$ command1 & command2 & command3 &
同时执行上面三个命令，输出进程id
-------------------------------------------------
4.6 用 && 减少if语句的使用
$cd mytmp && ls 
如果 && 前面的命令成功执行，即exit状态为0，才执行第二条命令
（注意，这和C语言中 && 的行为完全相反）
-------------------------------------------------
4.7 在退出bash以后，还能运行的命令
$nohup command1  &
将输出添加到nohup.out文件的后面
（但不能用这种方式执行GUI命令）
-------------------------------------------------
4.8 当命令执行出错时，输出错误信息
$cmd || printf "%b" "cmd failed. You're on your own\n"
-------------------------------------------------
4.9 执行保存在变量中的命令
PROGRAM=echo
$PROGRAM "some text"
-------------------------------------------------
4.10 执行目录中的所有脚本
run_all_script.sh
for SCRIPT in /somepath/dir/*
do
	if [ -f $SCRIPT -a -x $SCRIPT ];then
	   $SCRIPT	
	fi
done
-------------------------------------------------
========================================================
-------------------------------------------------------
5.1 单行注释
# This is a comment.
-------------------------------------------------------
5.2 多行注释
embedded_documentation.sh
使用:，即空操作和Here文档
:<<'END_OF_DOCS'
这是多行注释
。。。
很多行的
END_FO_DOCS
-------------------------------------------------------
5.5 全局变量
export MYVAR	#这样在该作用域的MYVAR就是全局变量
-------------------------------------------------------
5.6 观测所有的全局变量
执行env 或则 export -p
-------------------------------------------------------
5.7 命令行参数
"$1" “${1}” 表示第一个参数
"$2" “${2}” 表示第二个参数，以此类推
#由于每个参数有可能有空格，如“hello world”，所以，$1两边必须有双引号
-------------------------------------------------------
5.8 所有的命令参数用$*来表示(过时的方式)
chmod_750_all.1.sh
-------------------------------------------------------
5.10 所有的命令参数用“$@"来表示(正确用法)
chmod_750_all.2.sh
$*和$@表示的字符串相同，但“$*”是对所有参数组成的字符串，
而"$@"则是对每个参数加双引号。
e.g:目录中有三个mp3文件:1.mp3,the sec.mp3,third.mp3.
执行./my_script.sh *.mp3 以后,在my_script.sh中，
"$*" 表示 “1.mp3 the sec.mp3 third.mp3.”
“$@” 表示 “1.mp3” "the sec.mp3" "third.mp3"
-------------------------------------------------------
5.11 获得变量的个数$#
check_arg_count.sh
-------------------------------------------------------
5.12 命令行选项的处理（用shift n；减去前n个命令行参数）
use_up_option.sh
-------------------------------------------------------
5.13 获得默认值，用${:-}
FILEDIR=${1:-"/tmp"}
如果没有$1,则默认值为"/tmp"
-------------------------------------------------------
5.14 设置默认值,用${:=}
cd ${SOME_DIR:=/tmp}
如果没有SOME_DIR,或SOME_DIR为空,则默认值为/tmp
-------------------------------------------------------
5.15 设置默认值，用${=}
cd ${SOME_DIR=/tmp}
只有SOME_DIR不存在是,默认值为/tmp。
如果SOME_DIR为空，则${SOME_DIR=/tmp}的结果照样为空。
-------------------------------------------------------
5.16 用非常量设置默认值
cd ${BASE:="$(pwd)"}
-------------------------------------------------------
5.17 当某个变量没有设置时，输出报错信息
check_unset_parms.sh
${1:?"Error.You must supply the first arg."}
-------------------------------------------------------
5.18 改变变量中一部分字符串
suffixer.sh	批量修改文件后缀（应该使用下面第一种方法）
${string%pattern}	删除符合正则表达式的最短字符串
${string%%pattern}	删除符合正则表达式的最长字符串
${name/pattern/string}	替代第一个符合正则表达是的字符串
${name//pattern/string}	替代所有的符合正则表达是的字符串
-------------------------------------------------------
5.19 使用数组（Bash目前只支持一维数组）
MYARR=(first second third home)
那么"${MYARR[2]}"就是"third"
-------------------------------------------------------
========================================================
------------------------------------------------------------
6.1 在bash中使用整数运算(注意等号两边不要有空格)
COUNT=$((COUNT+5+MAX*2))	#另外$(2**8)的结果是256
除非是命令行参数$1,$# 等,否则没有必要在变量前面加$
let COUNT+=5+MAX*2
let后边的参数每一个参数都是一个语句，如：let X+=5*2 Y-=3*2
------------------------------------------------------------
6.2 分支(注意if语句后边的空格不能少)
if [ $# -lt 3 ] ;then
printf "%b" "Error.Not enough arguments.\n"
fi
------------------------------------------------------------
6.3 测试文件是否存在、是否有权限、是否为目录
checkfile.sh
-e存在，-r可读，-w可写，-x可执行，-O文件拥有者，-s长度不为零
(has size)，-g Set-GID，-k粘住位（注意不是-t），-u Set-UID
-d目录，-f文件
-b块设备，-c字符设备，-p命名管道,-S套接字，-h和-L符号链接
------------------------------------------------------------
6.4 测试不止一个条件(-a,-o)
if [ -r $FILE -a -w $FILE ] ;then cat $FILE;fi
if [ -r "$FN" -a \( -f "$FN" -o -p "$FN" \) ];then ...
------------------------------------------------------------
6.5 测试字符串
checkstr.sh	两种测试方法
-z测试字符串是否为空
------------------------------------------------------------
6.6 测试是否相等
strvsnum.sh
用=或==测试字符串是否相等(" 05 " 不等于“5”),<,<=,>,>=,!=
用-eq测试整数是否相等,(" 05 " 等于“5”),-lt,-le,-gt,-ge,-ne
------------------------------------------------------------
6.7 通配符测试
（注意：通配符两边不要有“”，否则会被认为是该字符串 ）
（注意：在[[]]中不需要也不能用转义）
if [[ "$FILE" == *.jpg ]]...		#

#先用shopt -s extglob,然后就可以使用以下的通配符模式
if [[ "$FILE == *.@(jpg|jpeg)"]]...	# *.jpg或*.jpeg
if [[ "$FILE == *.*(j)"]]...	# *.或*.j或*.jj或*.jjj...
if [[ "$FILE == *.+(j)"]]...	#     *.j或*.jj或*.jjj...
if [[ "$FILE == *.?(j)"]]...	# *.或*.j
if [[ "$FILE == *.!(j)"]]...	# 除了*.j以外的东西
------------------------------------------------------------
6.8 正则表达式的测试
trackmatch.sh
用 =~ 测试字符串是否匹配一个正则表达式
匹配了以后，$BASH_REMATCH[1]存放着匹配正则表达式的第一个分组的字符串，
$BASH_REMATCH[0]则表示整个被匹配的字符串
------------------------------------------------------------
6.10 循环(注意条件中不能填 1，与C等不同，
bash中while中的条件为0时才进行循环，因为正确执行在Bash中返回值为0)
while (( COUNT < MAX ))
do ... done
while [ -x "$LOCKFILE" ]
do ... done
while read LINE_TEXT
do ... done
------------------------------------------------------------
6.11 用read遍历循环的方法,看一个例子：
$svn status somedir（能看看到目录下的文件状态）
M      somedir/amin.c
?      somedir/bmin.c
?      somedir/cmin.c
A      somedir/some.c
?      somedir/max.c
如果想要删除那些不再库里面的文件，可以用以下的方法：
svn status somedir | \
while read STATUS filename
do
	if [[ $STATUS == \? ]];then
	   echo "$filename"
	   rm -rf "$filename"
	fi
done 或者以下方法
svn status somedir | grep '^?' | cut -c 8- | \
    while read FN; do echo "$FN";rm -rf "$FN";done
------------------------------------------------------------
6.12 for循环和foreach循环
for (( i=0; i<10;i++));do echo $i;done
for i in dirA dirB dirC;do ... ;done
------------------------------------------------------------
6.14 case in 语句
case $FN in
     *.gif) dosomething1 "$FN"
     ;;
     *.png) dosomething2 "$FN"
     ;;
     *)printf "File not supported:%s" "$FN"
     ;;
esac效果同下
if [[ $FN == *.gif ]] ;then
   dosomething1 "$FN"
elif [[ $FN == *.png ]] ; then
   dosomething2 "$FN"
else
   printf "File not supported:%s" "$FN"
fi
------------------------------------------------------------
6.15 解析命令行参数
dashes.sh	可以指定字符和字符个数，输出N个字符组成的一条线
------------------------------------------------------------
6.16 创建简单的Menus
dbinit.1.sh	数据库初始化？？
dbinit.2.sh	数据库初始化？？
select VALUE in $SOME_LIST
do
    echo something
    # 一些处理
done
注意：在前面的章节讲过修改PS3就可以修改select的提示字符串
------------------------------------------------------------
6.17 实现计算器(两个)
func_calc.sh
rpncalc.sh
------------------------------------------------------------
========================================================
----------------------------------------------------------------------
7.1 从多个文件中找出复合（正则）表达式的行。
$grep printf ../ch06/*.sh （从指定的文件中找到含有字符串printf的行）
../ch06/dash.sh:printf "%s\n" "$DASHES"
../ch06/strvsnum.sh:printf "%s" "do they -eq as equal? "
../ch06/strvsnum.sh:printf "%s" "do they = as equal? "
如果不想看到右边的文件名，可以在grep后面加 -h 选项
如果只是想看到该字符串在不同文件中出现的次数,可以用 -c
----------------------------------------------------------------------
7.2 只获得出现字符串的文件名
$grep -l printf ../ch06/*.sh
可轻易产生想要处理的文件列表
$rm -i $(grep -l 'This file is obsolete' *)
----------------------------------------------------------------------
7.3 只想看到一个文件中是否有指定的字符串，不想有输出
$grep somestring bigdata.file > /dev/null
#以上命令如果成功找到字符串，$?为0（注意返回0表示程序正常结束）
$if [ $? -eq 0 ];then echo yes;else echo no;fi
----------------------------------------------------------------------
7.4 grep忽略大小写用-i（ignore case）
----------------------------------------------------------------------
7.5 以管道作为grep的输入(如果不提供文件名给grep，grep从STDIN中获得输入)
$somecommand | someothers | grep somestring
$gcc bigbadcode.c 2>&1 | grep -i error(先将STDERR重定向到STDIN)
----------------------------------------------------------------------
7.6 从查找的结果中排除有指定字符串的行（用-v选项）
$grep -i sometext logfile | grep -vi dontwanted
----------------------------------------------------------------------
7.7 grep支持正则表达式
用正则表达式匹配一个IP地址
ifconfig | grep '[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}'
----------------------------------------------------------------------
7.8 zgrep,zcat,gzcat来处理压缩文件
注意:zgrep还可在一个被破坏的压缩包中读取文件
----------------------------------------------------------------------
7.10 用awk只获取文件的第一部分
$awk '{print $1}' myinput.file 将打印myinput.file中每一行的第一个单词
$awk '{print $1}' < myinput.file	#作用同上
$cat myinput.file | awk '{print $1}' 	#作用同上，只是输入不同
$1第一个Field，awk中的Fields默认是由空白字符分割的，也可以用-F来指定分割字符。
$NF表示最后一个Field。$0比较特别，它不是一个Field，而是表示整行。
----------------------------------------------------------------------
7.11 用awk获取输出的一部分
比如只想获取ls输出的权限和文件名
$ls -l | awk '{print $1,$NF}'	或者以下带字符串格式化的形式
$ls -l | awk '{printf "%s %s\n",$1,$NF}'
----------------------------------------------------------------------
7.12 awk将每行都逆序输出
awk ‘{
    for (i=NF;i>0;i--){
    	printf "%s ",$i;
    }
    printf "\n"
}’
----------------------------------------------------------------------
7.13 计算列表中某一列的和
如，下面将计算ls -l中列出的所有文件大小的和，并在最后输出它的值
ls -l | awk '{sum +=$5} END {print sum}'
在{}代码块前，加END表示在其他程序完成后执行一次。加入BEGIN即在开始时执行。
----------------------------------------------------------------------
7.14 用awk中的哈希表来计算所有用户拥有的文件数
（这个程序要在执行前，不知道有那些用户）
用本目录下的asar.awk
$ls -lR /usr/local | awk -f asar.awk
----------------------------------------------------------------------
7.15 用awk画一个横向的柱状图
para.awk
----------------------------------------------------------------------
7.16 用awk查看一个段落(被改成擦看所有awk代码块)
用本目录下的para.awk
$awk -f para.awk < hist.awk #将查看hist.awk中，由{到}的代码块
----------------------------------------------------------------------
7.aa 指定awk的分割符用 -F
----------------------------------------------------------------------
========================================================
-------------------------------------------------------------
8.1 用sort排序
$somecommands | sort
-r 按逆序排列，-f或--ignore-case可以忽略大小写
-------------------------------------------------------------
8.2 排列数值
-n 排列数值
第七列-f7是用户使用的shell，uniq -c后显示各个shell使用的用户数。
$cut -d ':' -f7 /etc/passwd | sort | uniq-c | sort -rn
如果只是要列出所有的被用户使用的shell，用-u
$cut -d ':' -f7 /etc/passwd | sort -u
-------------------------------------------------------------
8.3 排列IP地址
$sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n ipaddr.list
对ipaddr.list中的ip地址进行排序
-t 指定用点（.）将每行分成几个field
-k 1,1n 表示用从第一个field开始，第一个field结束的字符串来排序。
   	 其中n指定了以数值的形式来排列。
后面的-k 2,2n用
-------------------------------------------------------------
8.4 截取每行的一部分
ps au | cut -c 12-15
截取当前运行的所有进程ID
	# awk可以完全代替同时使用 -d 和 -f的cut命令
	#可以同时使用 -d 和 -f
	#-d 指定分割符，-f指定要显示的域
	#如以下命令 以‘:’为分割符，取出第三到第七个field
	#$cat /etc/passwd | cut -d ':' -f 3-7
	#注意：cut 只擅长处理 以一个字符为分割符 的文件。
如果是由N个字符串分割的文件，还是用awk比较好。
而且awk还能提供很好的字符串格式化的功能。
因此，cut -c 和cut -b 是cut命令唯一有意义的两种用法。
-------------------------------------------------------------
8.5 去除重复的行
用uniq  $cat myfile | uniq
-------------------------------------------------------------
8.6 打包文件 压缩文件（全宇宙的Linux都支持的打包和压缩命令）
$tar -cvf backupfile.tar bash_code/
打包bash_code/目录下的所有文件到backupfile.tar（只打包不压缩）
（并不是所有平台的tar都支持压缩选项，不推荐使用废旧的-z来压缩(.tgz或.tar.gz)
用-j可以有最高级别的压缩(文件后缀为.tar.bz2)）
$gzip backupfile.tar
压缩backupfile.tar到backupfile.tar.gz
$zip -rl backupfile.zip bash_code/
打包的同时转换UNIX换行符到DOS换行符
另外，用ar打包生成c语言的库文件
-------------------------------------------------------------
8.7 解压缩/解包文件（可以先用file命令看该文件的类型）
$tar -xvf backupfile.tar
除了zip和rar包不能用以外，基本上通用（用unzip解压缩dos的包）
-------------------------------------------------------------
8.8 显示文件解压后在本目录中添加的文件夹和文件
$tar tf backupfile.tar | awk -F '{print $1}' | uniq
$tar tf backupfile.tar	#只显示包中的文件目录，不解压
-------------------------------------------------------------
8.9 字符转换
$cat be.fore | tr ';' ','  > af.ter	#把分号都转换成逗号
$cat be.fore | tr ';:.!?' ',' > af.ter	#把参数一指定的字符都转换成逗号
$cat be.fore | tr -s ' '  # 把多个空格转换成一个空格
$cat be.fore | tr -s 'ha'  # 把haha，hahaha等等转换成一个ha
-------------------------------------------------------------
8.10 大小写转换
$tr 'A-Z' 'a-z' < be.fore > af.ter
$tr '[:upper:]' '[:lower:]' < be.fore > af.ter
-------------------------------------------------------------
8.11 将DOS 文件转换成 Linux Format
tr -d '\r' < file.dos > file.txt
-------------------------------------------------------------
8.12 Translate the odd characters backup to simple ASCII like this:
$tr '\221\222\223\224\226\227' '\047\047""--' < odd.txt > plain.txt
典型的功能：从Word文档中提取ASCII字符（只适用与全英文的）
-------------------------------------------------------------
8.13 wc（word counter）计算文件行数，单词数，字符数
$wc data_file #计算文件行数，单词数，字符数
$wc -l data_file #行数
$wc -w data_file #单词数
$wc -c data_file #字符数
-------------------------------------------------------------
8.14 用fmt可以批量排版纯文本（只能进行简单的任务，意义不大,见fmt --help）
-------------------------------------------------------------
8.15 用less命令代替more命令
-------------------------------------------------------------
========================================================
--------------------------------------------------------------------------
9.1 找出当前目录下所有的文件，并将其移动到一个文件夹中
$find . -name '*.mp3' -print -exec mv '{}' ~/songs \;
'{}' 会被替换成find命令找出的结果,后面的‘\’标记着mv命令的结束
--------------------------------------------------------------------------
9.2 如果上面的命令在某些系统上运行有问题（不识别中文等字符）
$find . -name '*.mp3' -print0 | xargs -i -0 mv '{}' ~/songs
print后面的0告诉find用零字符'\0'代替find输出的换行符,
xargs 中的-0 表示用零字符来作为分割符(xargs默认使用空白字符作为分割符)
xargs 中的-i 告诉xargs用'{}'来指定前面的命令输出 在mv命令中的作为第一个参数。
(默认前面的命令输出的 是mv的最后一个参数)
$find some_dir -type f -print0 | xargs -0 chmod 0644 
将某个目录下面所有的文件，权限改成0644.
注意：普遍地，使用xargs命令要比在find中添加-exec选项要快得多
（xargs加-i以后速度和find差不多）。
--------------------------------------------------------------------------
9.4 find命令加上-follow选项后可以"find files across symbolic links"
find . -follow -name '*.mp3' -print0 | xargs -i -0 cp '{}' ~/songs
--------------------------------------------------------------------------
9.5 忽略大小写地寻找文件（用-iname代替-name）
find . -follow -iname '*.mp3' -print0 | xargs -i -0 cp '{}' ~/songs
find . -follow -name '*.[Mm][Pp]3' -print0 | xargs -i -0 cp '{}' ~/songs
#也可以用正则表达式，但可读性没有前一个方法好
--------------------------------------------------------------------------
9.6 根据文件修改时间来找文件
find . -name '*.jpg' -mtime +90 -print
(加号表示九十天之前被修改过的文件)(90天以上)
find . -name '*.jpg' -mtime -90 -print
(减号表示九十天之内被修改过的文件)(90天以内)
find . -name '*.jpg' -mtime 90 -print
(修改日期距今天刚好90天)(90天的时候)
find . -mtime +7 -a -mtime -14 -print (可以在find命令中用AND)
find . mtime +14 -name '*.text' -o \( -mtime -14 -name '*.txt' \)
可以在find命令中用OR,
注意AND、OR、NOT的条件可以不止一个，用\(和\),也可以用'('和')'
NOT 用 -not 选项
找到最近30分钟被修改的*.erl文件和*.config文件
find ./ -cmin -30 | egrep '(config|erl)$'
--------------------------------------------------------------------------
9.7 指定寻找的文件类型
find . -name '*java*' -type d -print
其中-type d指定寻找文件的类型为目录
b块设备，c字符设备，d目录，f文件，p管道(包括FIFO)，l符号链接，s套接字
--------------------------------------------------------------------------
9.8 根据文件大小找文件
find . -size +3000k -print
--------------------------------------------------------------------------
9.9 根据文件内容找文件
find . name '*.txt' -exec grep -Hi songs '{}' \;
找到内容里面有songs这个单词的文件
选项-H指定grep命令在找到的行前面显示文件名
--------------------------------------------------------------------------
9.10 用locate或slocate快速寻找文件
再高级一点的搜索工具就要靠其他桌面应用程序了
Google Desktop Search(新版有支持Linux的) 和 Copernic Desktop (Windows!!)
--------------------------------------------------------------------------
9.11 在一串目录中找文件
如果是在PATH中 source myfile 可以找文件
如果是在PATH中且有执行权限，以下的方法都是可用的
type -P filename #type -P会直接显示该命令所在的位置，而不会显示alias的结果，
这样的话，下面的代码就不会因为alias而执行出错
LS=$(type -P ls)
if [ -x $LS ];then
   echo $LS is executable
fi

如果要遍历PATH的话(将PATH的:好转换成空格)
for path in ${PATH//:/ }; do ... done
--------------------------------------------------------------------------
9.A1 统计某目录下的文件数、所有文件的总行数
1.统计demo目录下，js文件数量：
find demo/ -name "*.js" |wc -l
2.统计demo目录下所有js文件代码行数：
find demo/ -name "*.js" |xargs cat|wc -l 或 wc -l `find ./ -name "*.js"`|tail -n1
3.统计demo目录下所有js文件代码行数，过滤了空行：
find /demo -name "*.js" |xargs cat|grep -v ^$|wc -l
--------------------------------------------------------------------------
--------------------------------------------------------------------------
========================================================
------------------------------------------------------------------
10.1 创建守护进程(在用SSH登陆时非常实用)
nohup mydaemon_script 0<&- 1>/dev/null 2&1 &
或者
nohup mydaemon_script >>/var/log/myadmin.log 2>&1 <&- &
用0<&-将破折号重定向到标准输入的意思是：关闭标准输入。
将1重定向到一个文件，再将2也重定向到1的那个文件。
>>是追加的方式重定向1到一个文件
重定向到/dev/null的内容就是丢弃的内容。
------------------------------------------------------------------
10.2 用bash文件作为配置文件（配合source命令）
配置文件执行完毕以后，变量的值不会继续保存，而是丢弃。
用source命令执行配置文件
如：source ~/.bashrc
. ~/.bashrc和$include ~/.bashrc也有同样的作用
（要十分注意的是，$include中的$也是命令的一部分，而不是命令提示符）
（上面命令是有一定的风险的，他们都是一个敞开的大门。
在source的时候要十分小心）
------------------------------------------------------------------
10.5  定义函数
func_max.1.sh
别忘了参数检查和必要时添加参数
在函数中，$FUNCNAME 变量是函数名(仅在函数执行是有值)
$0是脚本的名字(不含路径)
函数中的局部变量(有local声明的)在函数执行完以后不再存在
函数中的全部变量(没有local声明的)，在定义该函数的文件中一直有效
source一个文件以后，该文件定义的函数和全局变量会一直有效
------------------------------------------------------------------
10.6 使用信号
trap -l 或者 kill -l 会列出所有的信号
Note that the exit status of your script will be 128+signal number 
if the command was terminated by signal signal number.
hard_to_kill.sh
$kill -INT 1377
向进程号为1377的程序，发送INT信号
$kill -USR1 %1
向jobs号（用jobs命令查看）为1的进程，发送USR1信号
(用户定义的信号常常以USR加数值来命名)
------------------------------------------------------------------
10.7 alias的使用（执行命令时的优先级:函数 > alias > builtin）
alias emacs='emacs -nw'
alias ls='ls --color=auto'
执行完alias以后
执行emacs等于执行emacs -nw后面的命令
注意：以alias作为变量的名字是不合法的（为了安全性）
用unalias emacs 来取消之前alias的效果
------------------------------------------------------------------
10.8 避免alias和函数起作用
$builtin echo test
用builtin的echo来执行命令（不会把echo看做是函数或者alias）
$\echo test
不会吧echo看做是alias，如果echo被定义成一个函数则执行该函数，
否则执行builtin的echo
可以定义以下函数改变cd的行为，并且避免alias
function cd ( ){
    if [[ $1 = "..." ]]
    then
        builtin cd ../..
    else
        builtin cd $1
    fi
}
------------------------------------------------------------------

========================================================
------------------------------------------------------------------ 
11.1 date的格式化输出
ISO_8601_1='%Y-%m-%d %T %Z'	#这个变量的定义一般放在配置文件/脚本中
$date "+$ISO_8601_1" 		#使用变量进行格式化的方法
$date -d '2005-11-06' "+$ISO_8601_1" 	#(用-d选项)格式化特定的时间
$date -d 'last week Monday 12:00:00' '+%Y-%m-%d' 
#用指定的格式输出上周一的日期
-d选项还可以用以下单词
today,yesterday,this Monday,next Monday,last Monday,next 2 weeks,
+2 weeks,2 weeks ago,-2 weeks,+4 days,3 months 1 day ago,.....
------------------------------------------------------------------
11.4 将date以新纪元秒的形式来显示
date '+%s'
------------------------------------------------------------------ 
11.5 将新纪元秒转换成日期
EPOCH=1131173989
date -d "1970-01-01 UTC $EPOCH seconds" "+%Y-%m-%d %T %z" #本地时间
date --utc -d "1970-01-01 UTC $EPOCH seconds" "+%Y-%m-%d %T %z"  #UTC时间
------------------------------------------------------------------
11.7 日期的计算
CORRECTION='172800'		#两天的秒数
bad_date='Jan 2 05:13:05'	#
bad_epoch=$(date -d "$bad_date" '+%s') #转换成新纪元秒
good_epoch=$(( bad_epoch + $CORRECTION )) #日期的相加
#good_date是转换好的日子
good_date=$(date -d "1970-01-01 UTC $bad_epoch seconds" "+%Y-%m-%d %T")
------------------------------------------------------------------ 
11.8 时区、夏令时间和闰年
噩梦，见 date --help和 man date
------------------------------------------------------------------ 
11.9 在每个月第N个星期三用cron 做某事
大部分的cron不能处理这个问题。用以下方法解决：在第N周的每一天都检
查当天是否为星期三。
#Vixie Cron
# Min  Hour	DoM	Mnth	DoW	Program
# 0-59 0-23	1-31	1-12 	0-7
# 以下配置项中，00分钟，23点，第8到14天，*在这个位置代表所有月份，
# Wed是周三 后面是要执行的任务
00 23 8-14 * Wed [ "$(date '+%a')" == "Wed" ] && /path/to/command
cron 的配置文件在/etc/crontab，或者在/var/spool/cron下添加对应用户的配置文件。
注意cron中执行的命令要带全路径或则在配置文件的开头指定目录
------------------------------------------------------------------ 
11.10 输出月历和年历
cal 10 2006
cal 2012
------------------------------------------------------------------ 
========================================================
------------------------------------------------------------------------
12.1 输出点号的例子
dash.sh
------------------------------------------------------------------------
12.2 用一个模板生成不同的文件
mkalbum.sh
根据文件名字生成Html，可方便地浏览图片的一个例子。
用法
ls *.jpg | ./mkalbum.sh pictures_dir/ 或者
basename的用法
去掉前导的目录部分后打印"名称"。
如果指定的话，还会去掉尾随的"后缀"。
示例：
  basename /usr/bin/sort       输出"sort"。
  basename include/stdio.h .h  输出"stdio"。
------------------------------------------------------------------------
12.3 一直拷贝mp3文件到U盘，直到U盘的容量放不下文件为止
load_mp3.sh
用set改变命令行的参数
set -- this is a test
以上命令执行完了以后,命令行参数会被改变
$1 为this，$2为is,$3为a,$4为test.
------------------------------------------------------------------------
12.4 烧写一个CD(不实用)
cdscript.sh
需要用到mkisofs和cdrecord两个程序()
------------------------------------------------------------------------
12.5 比较两个OpenOffice的文件(不实用，Diff Doc，Word Diff Doc，svn等等)
ooddiff.sh
------------------------------------------------------------------------
========================================================
------------------------------------------------------------------------
13.1 解析命令行参数的例子
getopts_example.sh
------------------------------------------------------------------------
13.2 将输出保存在数组中哦
parseViaArray.sh
------------------------------------------------------------------------
13.3 用函数解析输出
parseViaFunc.sh
------------------------------------------------------------------------
13.4 一个一个地处理字符
onebyone.sh
------------------------------------------------------------------------
13.5 去除一行中前后的空白字符
shopt -s extglob
while IFS= read -r line; do
      echo "None: ~~$line~~"
      echo "Ld: ~~${line##+([[:space:]])}~~"
      echo "Tr: ~~${line%%+([[:space:]])}~~"
      line="${line##+([[:space:]])}"
      line="${line%%+([[:space:]])}"
      echo "All: ~~$line~~"
done < whitespace
------------------------------------------------------------------------
13.5 将多个空格改成一个TAB
$ cat data_file
Header1        Header2		Header3
Rec1_Field1    Rec1_Field2      Rec1_Field3
Rec2_Field1  Rec2_Field2      Rec2_Field3
Rec3_Field1     Rec3_Field2      Rec3_Field3

$ cat data_file | tr -s ' ' '\t'
Header1 ➝ Header2 ➝ Header3
Rec1_Field1 ➝ Rec1_Field2 ➝ Rec1_Field3
Rec2_Field1 ➝ Rec2_Field2 ➝ Rec2_Field3
Rec3_Field1 ➝ Rec3_Field2 ➝ Rec3_Field3
------------------------------------------------------------------------
========================================================
------------------------------------------------------------------------
14.1 避免安全问题
a.对所有输入进行合法性验证(包括配置文件和交互式输入).
特别地,永远不要eval未经确认的输入.
b.使用临时文件(最好在临时目录中),见14.10
c.使用可靠的外部命令.
------------------------------------------------------------------------
14.2 设置一个安全的$PATH
Set $PATH to a known good state at the beginning of every script:
# Set a sane/secure path
PATH='/usr/local/bin:/bin:/usr/bin'
# It's almost certainly already marked for export, but make sure
export PATH
Or use the getconf utility to get a path guaranteed by POSIX to 
find all of the standard utilities:
export PATH=$(getconf PATH)
------------------------------------------------------------------------
14.3 清除所有的Aliases
# Clear all aliases.  Important: leading \ inhibits alias expansion 
\unalias -a
------------------------------------------------------------------------
14.4 用hash -r来清除所有的命令hash
(命令hash机制有bash自动完成,目的是提高bash的速度)
If an attacker can trick root or even another user into running a command,
they will be able to gain access to data or privileges they shouldn’t have. 
------------------------------------------------------------------------
14.5 用ulimit修改shell资源限制
ulimit -H -c 0 或 ulimit -H -c 0 --
#使用硬资源限制,并将core file的大小设置为0,这样就可以
Prevent your script from dumping core in the case of an unrecoverable error,
since core dumps may contain sensitive data from memory such as passwords.
------------------------------------------------------------------------
14.6 Setting a Secure $IFS
# Set a sane/secure IFS (note this is bash & ksh93 syntax only--not portable!)
IFS=$' \t\n'
------------------------------------------------------------------------
14.7 Setting a Secure umask
使用built-in 的umask(在每个脚本开头) 设置一个安全的状态
# umask的值是:从新创建的文件中"拿掉"的权限
# 比如umask值设为002,那新创建的文件权限就为0775
UMASK=002
umask $UMASK
------------------------------------------------------------------------
14.8 Finding World-Writable Directories in Your $PATH
chkpath.1.sh
chkpath.2.sh
------------------------------------------------------------------------
14.9 不要将当前目录添加到$PATH
root尤其不能这样做.
If you absolutely must do this, make sure . comes last.
------------------------------------------------------------------------
14.10 创建安全的临时文件(保证临时文件是存在的)
make_temp.sh
清除临时文件
clean_temp.sh
------------------------------------------------------------------------
14.11 对输入进行合法性验证
下面的例子用case语句验证输入的合法性
validate_using_case.sh
------------------------------------------------------------------------
14.12 合理地设置权限
谨慎地使用chmod -R 0644 some_directory
可以参考以下的命令
$find some_directory -type f | xargs chmod 0644	# File perms
$ find some_directory -type d | xargs chmod 0755 # File perms
------------------------------------------------------------------------
14.13 在命令中不要显式地留下密码
./my_app -u user -p password &
------------------------------------------------------------------------
14.14 setuid和setgid脚本有严重的安全漏洞
庆幸的是Linux下,setuid和setgid权限不能加给脚本文件
------------------------------------------------------------------------
14.15 避免使用shared accounts
------------------------------------------------------------------------
14.16 不得不使用不信任的程序或脚本时,先chroot
------------------------------------------------------------------------
14.17 在不需要root密码的情况下,得到root权限
由root编辑/etc/sudoers文件
------------------------------------------------------------------------
14.18 Avoid hardcode a password in a script(不得不需要密码的情况下)
You can use sudo with the NOPASSWD option to 
avoid having to hardcode a password anywhere. 
------------------------------------------------------------------------
14.19 不需要密码的情况下使用SSH
详见《鸟哥的Linux私房菜 服务器架设篇（第二版）》 P300～P302
------------------------------------------------------------------------
14.20 安全的shell脚本的模板（综合以上一部分知识）
security_template.sh
------------------------------------------------------------------------
========================================================
------------------------------------------------------------------------
15.1 用#!/usr/bin/env bash代替其它形式的(如果有足够的理由，也允许例外)
------------------------------------------------------------------------
15.2 Splitting Output Only When Necessary
func_split.sh
见第八章对split命令的介绍
------------------------------------------------------------------------
15.3 用hex形式查看文件
hexdump -C filename
------------------------------------------------------------------------
15.4 查找ip地址(本例在中文环境中不能正确执行)
finding_ipas.sh
------------------------------------------------------------------------
15.5 将脚本的错误输出丢弃
最方便的方法：  ./myscript.sh > /dev/null
# Redirect any output to STDERR to an error log file instead
exec 2> /path/to/error_log
------------------------------------------------------------------------
15.6 用脚本发邮件
email_sample.sh
email_sample_css.sh
在cron中添加相应的处理可以定时发送邮件
注意：Ubuntu不支持mail命令
------------------------------------------------------------------------
15.7 Getting input from another marchine
command_substitution.sh
------------------------------------------------------------------------
========================================================
------------------------------------------------------------------------
16.1 bash帮助
bash --help
bash -c help 或 bash -c "help set"
------------------------------------------------------------------------
16.2 设置命令提示符
修改PS1可以，详见
prompts.sh
PS2是二级命令提示符
------------------------------------------------------------------------
16.3 修改$PATH
只对单个帐号有用的修改，一般在 ~/.profile 或 ~/.bash_profile中修改
If you are root and you need to set the path for the entire system, 
The most likely file is /etc/profile, /etc/bashrc, /etc/rc, 
/etc/default/login, ~/.ssh/environment, 
------------------------------------------------------------------------
16.4 在PATH中添加或删除路径的一些函数
func_tweak_path.sh
------------------------------------------------------------------------
16.5 快速切换路径
适当地设置环境变量 CDPATH
比如，CDPATH=".:/home/cmj/a_files/aa.coding/sa-bash/bashcookbook"
这样，在任何路径下都可以直接cd 到bashcookbook下的任意目录
------------------------------------------------------------------------
16.6 通过set和shopt命令可以改变Shell的默认行为（见Bash Cookbook 附录A）
------------------------------------------------------------------------
16.7 修改readline Behavior
创建或编辑 ~/.inputrc or /etc/inputrc
设置环境变量INPUTRC='~/.inputrc'. 
通过bind -f filename 可以测试一个inputrc文件的效果
具体设置看以下文件
inputrc
------------------------------------------------------------------------
16.8 可以考虑使用Private Utilities（并添加～/bin/到PATH）
------------------------------------------------------------------------
16.9 PS2，PS3,PS4
PS2 通常设置为‘>,叫二级提示符，当命令要分行输入时，第二行以后的提示符。
PS3 通常select语句的提示符
------------------------------------------------------------------------
16.10 用history命令来显示先前执行过的命令
配置环境变量HISTTIMEFORMAT=': %Y-%m-%d_%H:%M:%S;‘
history命令如果带参数的话
      -a		      将当前绘画的历史行追加到历史文件中
      -n		      从历史文件中读取所有未被读取的行
环境变量HISTFILE设置历史文件，没有设置该变量则使用 ~/.bash_history 文件
------------------------------------------------------------------------
16.11 设置PROMPT_COMMAND环境变量
PROMPT_COMMAND='history -a ; history -n'
在每次打印$PS1的时候，该变量的中命令都会执行
#这连个命令完成了
------------------------------------------------------------------------
16.12 创建一个目录并且进入它
func_mcd.sh
------------------------------------------------------------------------

========================================================
------------------------------------------------------------------------
17.1 重命名很多文件
#将文件后缀名从bad改成bash（注意用的是%号）
#注意文件名等参数必须要用双引号围住
for FN in *.bad
do
mv "${FN}" "${FN%bad}bash"
done
------------------------------------------------------------------------
17.2 info bash | less（用emacs-like编辑器打开文档）
------------------------------------------------------------------------
17.3 解压文件
unzip '*.zip'
for x in /path/to/date*/name/*.zip; do unzip "$x"; done
或者
for x in $(ls /path/to/date*/name/*.zip 2>/dev/null); do unzip $x; done
------------------------------------------------------------------------
17.4~17.7 用screen来共享一个bash的session（screen是一个GNU软件）
------------------------------------------------------------------------
17.8 获取文件的元数据
archive_meta-data.sh
注意-o是OR的意思
The (-path /foo -o -path ...) -prune part removes various 
directories you probably don’t want to bother wit.
------------------------------------------------------------------------
17.9 使用diff和patch命令
用以下的命令创建一个补丁
diff -u original_file modified_file > your_patch.patch
(推荐使用diff的-u选项,不推荐使用diff的-c选项)
用以下命令应用一个补丁
cd /path/to/files/
patch -Np1 < your_patch
(-N防止补丁被多次应用或撤销应用,-p1使可以在不同的文件夹之间创建和应用补丁)
------------------------------------------------------------------------
17.10 找出两个文件中有多少不一样的地方
$ diff -u original_file modified_file | grep -c "^@@"
------------------------------------------------------------------------
17.11 处理奇葩式的文件名(如:--help或this is a *crazy* file name! )
$ mv -- --help my_help.txt #在第一个参数前面加入--,使命令不被看作打开帮助
$ mv this\ is\ a\ \*crazy\*\ file\ name\! this_is_a_better_name
------------------------------------------------------------------------
17.12 在不改变inode的情况下改变文件的内容
# 使用ed在文件开关处加入两行文本的命令
$ printf "%b" '1\ni\nHeader Line1\nHeader Line2\n.\nw\nq\n' | ed -s data_file
# ed工具可以使用脚本,下面是一个简单的ed脚本
$ cat ed_script
1
i
Header Line1
Header Line2
.
w
q

#应用脚本的方法很简单
$ ed -s data_file < ed_script
1 foo
$ cat data_file
Header Line1
Header Line2
1 foo
2 bar
3 baz
------------------------------------------------------------------------
17.13 使用sudo执行多条命令
#下面的方法是不对的,只有command1是以root权限执行的,其它都不是
sudo 'command1 && command2 || command3'
#下面的方法是对的,可以执行多条命令
sudo bash -c 'command1 && command2 || command3'
sudo -l 和以看到本用户拥有那些权限
------------------------------------------------------------------------
17.14 从两个文件中找到一文件的某些(不在另一个文件中的)行
comm,diff,sort和uniq都可以用(注意grep不适合做这类工作,grep不是整行匹配的)
$ cat left		#第一个示例文件left
record_01
record_02.left only
record_03
record_05.differ
record_06
record_07
record_08
record_09
record_10

$ cat right		#第二个示例文件right
record_01
record_02
record_04
record_05
record_06.differ
record_07
record_08
record_09.right only
record_10

# 只输出在left中存在的行
$ comm -23 left right
record_02.left only
record_03
record_05.differ
record_06
record_09

# 只输出在right中存在的行
$ comm -13 left right
record_02
record_04
record_05
record_06.differ
record_09.right only

# 只输出在两个文件中存在的行
$ comm -12 left right
record_01
record_07
record_08
record_10

#比较两个文件的不同(有些系统使用sdiff代替diff -y)
$ diff -y -W 60 left right
record_01			record_01
record_02.left only	|	record_02
record_03      		|	record_04
record_05.differ	|	record_05
record_06		|	record_06.differ
record_07			record_07
record_08			record_08
record_09		|	record_09.right only
record_10			record_10

#只显示两个文件不同的地方
$ diff -y -W 60 --suppress-common-lines left right
record_02.left only	| record_02
record_03      		| record_04
record_05.differ	| record_05
record_06		| record_06.differ
record_09		| record_09.right only

#将两个文件的行排序并只打印不同的行
$ sort right left | uniq -u
record_02
record_02.left only
record_03
record_04
record_05
record_05.differ
record_06
record_06.differ
record_09
record_09.right only

#将两个文件相同的行输出来
$ sort right left | uniq -u
record_02
record_02.left only
record_03
record_04
record_05
record_05.differ
record_06
record_06.differ
record_09
record_09.right only
------------------------------------------------------------------------
17.15 保存N个文件名s或目录名s
func_shift_by.sh
用法如下
$ source shift_by.sh
$ ls ?
1 2 3 4 5 6 7 8 9
$ shift_by 3 $(ls ?)
4 5 6 7 8 9
$ shift_by 5 $(ls ?)
6 7 8 9
$ shift_by 5 $(ls -r ?)
4 3 2 1
$ shift_by 7 $(ls ?)
8 9
$ shift_by 9 $(ls ?)
# Keep only the last 5 objects
$ echo "rm -rf $(shift_by 5 $(ls ?))"
rm -rf 6 7 8 9
# In production we'd test this first!
$ rm -rf $(shift_by 5 $(ls ?))
See discussion.
$ ls ?
1 2 3 4 5
------------------------------------------------------------------------
17.16 grep ps的输出,同时屏蔽掉grep本身的进程
ps aux | grep 'ssh' | grep -v grep
------------------------------------------------------------------------
17.17 找出进程是否正在运行(ps命令在不同的OS下差别太大)
is_process_running.sh
# Linux
$ ps -wwo pid,args -p 1394 | grep 'bin/sshd'
1394 /usr/sbin/sshd
------------------------------------------------------------------------
17.18 给文件添加前缀或后缀
$ last | while read i; do [[ -n "$i" ]] && printf "%b" "$HOSTNAME\t$i\n"; done
# Write a new logfile
$ last | while read i; do [[ -n "$i" ]] && printf "%b" "$HOSTNAME\t$i\n"; done >
last_$HOSTNAME.log
或者可以用awk给每行添加文本
$ last | awk "BEGIN { OFS=\"\t\" } ! /^\$/ { print \"$HOSTNAME\", \$0}"
$ last | awk "BEGIN { OFS=\"\t\" } ! /^\$/ { print \"$HOSTNAME\", \$0}" \
> last_$HOSTNAME.log
------------------------------------------------------------------------
17.19 添加行号
当然可以用循环来做
$i=0; while IFS= read -r line; do (( i++ )); echo "$i $line"; done < lines
1 Line 1
2 Line 2
3 
4 Line 4
5 Line 5

#或者用cat来做
$ cat -n lines
1 Line 1
2 Line 2
3
4 Line 4
5 Line 5
6

$ cat -b lines
1 Line 1
2 Line 2

3 Line 4
4 Line 5

#再或者用nl命令来做
$ nl lines
1 Line 1
2 Line 2
3 Line 4
4 Line 5

$ nl -ba lines
1 Line 1
2 Line 2
3
4 Line 4
5 Line 5
6

#用awk做也是可以的
awk '{ print NR, $0 }' filename
1 Line 1
2 Line 2
3 
4 Line 4
5 Line 5
6
------------------------------------------------------------------------
17.20 产生一个随机的文件 或 写一个数列
添加/dev/null作为参数是为了在solaris中正常运行(Linux中不需要第二个参数)
$ awk 'END { for (i=1; i <= 5; i++) print i, "text"}' /dev/null
1 text
2 text
3 text
4 text
5 text

#bash中没有小数,所以用到awk
awk 'BEGIN { for (i=1; i <= 5; i+=.5) print i}' /dev/null
1
1.5
2
2.5
3
3.5
4
4.5
5

# Bash 2.04+ only, integer only
$ for ((i=1; i<=5; i++)); do echo "$i text"; done
1 text
2 text
3 text
4 text
5 text

# Bash 3.0+ only, integer or single character only
$ printf "%s text\n" {1..5}
1 text
2 text
3 text
4 text
5 text

$ printf "%s text\n" {a..e}
a text
b text
c text
d text
e text
------------------------------------------------------------------------
17.21 添加thousands-place分隔符到一个大的数字
$ LC_NUMERIC=en_US.UTF-8 printf "%'d\n" 123456789
123,456,789
$ LC_NUMERIC=en_US.UTF-8 printf "%'f\n" 123456789.987
123,456,789.987000
以下是只依靠bash的版本
func_commify.sh
------------------------------------------------------------------------


========================================================
------------------------------------------------------------------------
18.1 使用pushd和popd命令快速切换目录(用dirs来查看栈中的所有目录)
使用pushd命令（而不是cd）来切换目录。
比如，当前目录是/tmp/tank的话，
$pwd
/tmp/tank
执行pushd /home/cmj可将当前目录压入栈中，并来切换到/home/cmj。
$push /home/cmj
$pwd
/home/cmj
$dirs -v 
0 /home/cmj
1 /tmp/tank
如果执行popd的话，将会进入栈中前一个目录（也就是/tmp/tank）。
用dirs -v列出所有的目录（并附上在栈中的位置）

如果$dir -v（注意，输出中，0是但前目录）
0 /var/tmp
1 ~/part/me/scratch
2 /tmp
这时候如果执行$pushd +2 将目录2和目录0的位置调换(即当前目录被设为目录2)
------------------------------------------------------------------------
18.2 重复上一条命令
在命令行中输入!!
（还不如C-p ENTER呢）
------------------------------------------------------------------------
18.3 输入几乎相同的命令（不推荐使用的方法）
$ /usr/bin/somewhere/someprog -g -H -yknot -w /tmp/soforthandsoon
Error: -H not recognized. Did you mean -A?
$ !!:s/H/A/   		  
#将H换成A（注意只能替换一个单词，而且也会把其它的H换掉哦）
/usr/bin/somewhere/someprog -g -A -yknot -w /tmp/soforthandsoon
------------------------------------------------------------------------
18.4 输入几乎相同的命令（推荐使用）
$ /usr/bin/somewhere/someprog -g -A -yknot -w /tmp/soforthandsoon
...
$ ^-g -A^-gB^
#将“- -A” 替换成-g（可以替换多个单词）
/usr/bin/somewhere/someprog -gB -yknot -w /tmp/soforthandsoon
使用方法：即使只是把-gA改成-gB，
用^-gA -yk^-gB -yk^要比^A^B^好多了（因为可以避免A匹配目录名中其它的字符）
------------------------------------------------------------------------
18.5 重复上条命令的参数
$ vi /some/long/path/name/you/only/type/once
...
$ gcc !$	##重复上一条命令中的第二个参数
gcc /some/long/path/name/you/only/type/once
...

$ munge /opt/my/long/path/toa/file | more
...
$ vi !:1	##重复上一条命令中的第一个参数
vi /opt/my/long/path/toa/file
------------------------------------------------------------------------
18.6 常用，多用TAB
------------------------------------------------------------------------



========================================================
================ch19常见错误============================================
------------------------------------------------------------------------
19.1 忘记设置执行权限
chmod a+x myscript.sh或者直接bash myscript.sh
------------------------------------------------------------------------
19.2 执行脚本文件时，提示""No such file or director"
很有可能是换行符跟当前系统不匹配,见8.11
也有可能是bash文件开头没有#!/usr/bin/env bash
------------------------------------------------------------------------
19.3 忘记当前目录不再$PATH中
$myscripts.sh执行出错
$./myscripts.sh才对
------------------------------------------------------------------------
19.4 用test作为脚本的名字（和bash中的test冲突了）
------------------------------------------------------------------------
19.5 尝试修改已经exported的变量
first.sh
second.sh
------------------------------------------------------------------------
19.6 忘记使用双引号，
#!/bin/bash -
# common goof:
# X=$Y $Z
# isn't the same as
# X="$Y $Z"
#
OPT1=-l
OPT2=-h
#这样不能正常执行ls -l -h .
#ALLOPT=$OPT1 $OPT2

#这样才能正常执行
ALLOPT="$OPT1 $OPT2"
ls $ALLOPT .
------------------------------------------------------------------------
19.7 忘记模式匹配时产生的序列是按字母顺序排列的
$ mv x.[ba]
以为会执行
$ mv x.b x.a
但实际执行的是
$ mv x.a x.b
------------------------------------------------------------------------
19.8 Forgetting That Pipelines Make Subshells
You have a script that works just fine, reading input in a while loop:
COUNT=0
while read PREFIX GUTS
do
# ...
if [[ $PREFIX == "abc" ]]
then
let COUNT++
fi
# ...
done
echo $COUNT

and then you change it to read from a file:
cat $1 | while read PREFIX GUTS
do
# ...
only now it no longer works... $COUNT keeps coming out as zero.

Solution：
COUNT=0
while read PREFIX GUTS
do
# ...
done < $1
echo $COUNT
------------------------------------------------------------------------
19.9 不要使用/在变量的开头 如 /$files_to_delete
永远永远不能这样执行 rm -rf /$files_to_delete 永远不要
·[ "$files_to_delete" ] && rm -rf $files_to_delete
------------------------------------------------------------------------
19.10 没有给printf的参数加引号
oddscript.sh
------------------------------------------------------------------------
19.11 使用bash -n 来测试bash的语法！！！
------------------------------------------------------------------------
19.12 在bash的开头加入set -x，然后执行脚本就可Debug bash脚本了
注意还可以修改PS4来改变Debug时的显示
（比如$ export PS4='+xtrace $LINENO:'）
buggy.sh
As of bash 3.0 there are a number of new variables to better support
debugging:$BASH_ARGC, $BASH_ARGV, $BASH_SOURCE, $BASH_LINENO, 
$BASH_SUBSHELL, $BASH_EXECUTION_STRING, and $BASH_COMMAND. 
This is in addition to existing bash variables
like $LINENO and the array variable $FUNCNAME.
------------------------------------------------------------------------
19.13 不要混淆匹配的模式和正则表达式
Shell pattern matching is performed by:
• Filename globbing (pathname expansion)
• == and != operators for [[
• case statements
• $GLOBIGNORE handling
• $HISTIGNORE handling
• ${parameter#[#]word}
• ${parameter%[%]word}
• ${parameter/pattern/string}
• Several bindable readline commands (glob-expand-word, glob-complete-word,
etc.)

写bash脚本是，正则表达式用在 grep、awk、sed等工具中使用。
bash本身只在 =~ 中使用
------------------------------------------------------------------------
========================================================
A1.bashвֳɽű
yum install bash-completion (õһļ)
Ȼ.bashrc

if [ -r /etc/bash_completion ]; then
    source /etc/bash_completion
fi

1Ҫ룬Ҫ֪compgen÷
chenmingjian@WIN-7T7C6P50JB1 ~ 
$ compgen -W "aabb ab bb cc" 
aabb 
ab 
bb 
cc 

chenmingjian@WIN-7T7C6P50JB1 ~ 
$ compgen -W "aabb ab bb cc" -- "a" 
aabb 
ab 

chenmingjian@WIN-7T7C6P50JB1 ~ 
$ compgen -W "aabb ab bb cc" -- "aa" 
aabb 
========================================================
﻿1. Sed简介
sed 是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。以下介绍的是Gnu版本的Sed 3.02。
2. 定址
可以通过定址来定位你所希望编辑的行，该地址用数字构成，用逗号分隔的两个行数表示以这两行为起止的行的范围（包括行数表示的那两行）。如1，3表示1，2，3行，美元符号($)表示最后一行。范围可以通过数据，正则表达式或者二者结合的方式确定 。

3. Sed命令
调用sed命令有两种形式：
*
sed [options] 'command' file(s)
*
sed [options] -f scriptfile file(s)
a\
在当前行后面加入一行文本。
b lable
分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。
c\
用新的文本改变本行的文本。
d
从模板块（Pattern space）位置删除行。
D
删除模板块的第一行。
i\
在当前行上面插入文本。
h
拷贝模板块的内容到内存中的缓冲区。
H
追加模板块的内容到内存中的缓冲区
g
获得内存缓冲区的内容，并替代当前模板块中的文本。
G
获得内存缓冲区的内容，并追加到当前模板块文本的后面。
l
列表不能打印字符的清单。
n
读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。
N
追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。
p
打印模板块的行。
P（大写）
打印模板块的第一行。
q
退出Sed。
r file
从file中读行。
t label
if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
T label
错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。
w file
写并追加模板块到file末尾。
W file
写并追加模板块的第一行到file末尾。
!
表示后面的命令对所有没有被选定的行发生作用。
s/re/string
用string替换正则表达式re。
=
打印当前行号码。
#
把注释扩展到下一个换行符以前。
以下的是替换标记
*
g表示行内全面替换。
*
p表示打印行。
*
w表示把行写入一个文件。
*
x表示互换模板块中的文本和缓冲区中的文本。
*
y表示把一个字符翻译为另外的字符（但是不用于正则表达式）

4. 选项
-e command, --expression=command
允许多台编辑。
-h, --help
打印帮助，并显示bug列表的地址。
-n, --quiet, --silent

取消默认输出。
-f, --filer=script-file
引导sed脚本文件名。
-V, --version
打印版本和版权信息。

5. 元字符集^
锚定行的开始 如：/^sed/匹配所有以sed开头的行。 
$
锚定行的结束 如：/sed$/匹配所有以sed结尾的行。 
.
匹配一个非换行符的字符 如：/s.d/匹配s后接一个任意字符，然后是d。 
*
匹配零或多个字符 如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。 
[]
匹配一个指定范围内的字符，如/[Ss]ed/匹配sed和Sed。 
[^]
匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。 
\(..\)
保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。 
&
保存搜索字符用来替换其他字符，如s/love/**&**/，love这成**love**。 
\<
锚定单词的开始，如:/\<love/匹配包含以love开头的单词的行。 
\>
锚定单词的结束，如/love\>/匹配包含以love结尾的单词的行。 
x\{m\}
重复字符x，m次，如：/0\{5\}/匹配包含5个o的行。 
x\{m,\}
重复字符x,至少m次，如：/o\{5,\}/匹配至少有5个o的行。 
x\{m,n\}
重复字符x，至少m次，不多于n次，如：/o\{5,10\}/匹配5--10个o的行。
6. 实例
删除：d命令
*
$ sed '2d' example-----删除example文件的第二行。
*
$ sed '2,$d' example-----删除example文件的第二行到末尾所有行。
*
$ sed '$d' example-----删除example文件的最后一行。
*
$ sed '/test/'d example-----删除example文件所有包含test的行。
替换：s命令
*
$ sed 's/test/mytest/g' example-----在整行范围内把test替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytest。
*
$ sed -n 's/^test/mytest/p' example-----(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它。
*
$ sed 's/^192.168.0.1/&localhost/' example-----&符号表示替换换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加 localhost，变成192.168.0.1localhost。
*
$ sed -n 's/\(love\)able/\1rs/p' example-----love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。
*
$ sed 's#10#100#g' example-----不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100。
选定行的范围：逗号
*
$ sed -n '/test/,/check/p' example-----所有在模板test和check所确定的范围内的行都被打印。
*
$ sed -n '5,/^test/p' example-----打印从第五行开始到第一个包含以test开始的行之间的所有行。
*
$ sed '/test/,/check/s/$/sed test/' example-----对于模板test和west之间的行，每行的末尾用字符串sed test替换。
多点编辑：e命令
*
$ sed -e '1,5d' -e 's/test/check/' example-----(-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除1至5行，第二条命令用check替换test。命令的执 行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。
*
$ sed --expression='s/test/check/' --expression='/love/d' example-----一个比-e更好的命令是--expression。它能给sed表达式赋值。
从文件读入：r命令
*
$ sed '/test/r file' example-----file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面。
写入文件：w命令
*
$ sed -n '/test/w file' example-----在example中所有包含test的行都被写入file里。
追加命令：a命令
*
$ sed '/^test/a\\--->this is a example' example<-----'this is a example'被追加到以test开头的行后面，sed要求命令a后面有一个反斜杠。
插入：i命令
$ sed '/test/i\\
new line
-------------------------' example
如果test被匹配，则把反斜杠后面的文本插入到匹配行的前面。
下一个：n命令
*
$ sed '/test/{ n; s/aa/bb/; }' example-----如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续。
变形：y命令
*
$ sed '1,10y/abcde/ABCDE/' example-----把1--10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。
退出：q命令
*
$ sed '10q' example-----打印完第10行后，退出sed。
保持和获取：h命令和G命令
*
$ sed -e '/test/h' -e '$G example-----在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将 打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保 持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中 的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。
保持和互换：h命令和x命令
*
$ sed -e '/test/h' -e '/check/x' example -----互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换。
7. 脚本
Sed脚本是一个sed的命令清单，启动Sed时以-f选项引导脚本文件名。Sed对于脚本中输入的命令非常挑剔，在命令的末尾不能有任何空白或文本，如果在一行中有多个命令，要用分号分隔。以#开头的行为注释行，且不能跨行。

如何实现trim功能
\sed 's/^ //;s/ $//'